<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gemini 2.5 Flash Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { margin: 5px; padding: 10px; cursor: pointer; }
        .status { margin: 10px 0; padding: 5px; border-radius: 3px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #cce7ff; color: #004085; }
        textarea { width: 100%; margin: 5px 0; }
        select { width: 100%; padding: 5px; margin: 5px 0; }
    </style>
</head>
<body>
    <h3>Gemini 2.5 Flash Test - UPDATED WITH STREAMING SUPPORT</h3>
    <textarea id="promptInput" rows="5" placeholder="Enter your prompt...">hi, this is a test of your API, give 5 sentence response please.</textarea>
    <button onclick="submitPrompt(false)" style="background: #4285f4; color: white;">Submit to Gemini</button>
    <button onclick="submitPrompt(true)" style="background: #34a853; color: white;">Submit with Streaming</button>
    <button onclick="submitPrompt(false, true)" style="background: #ea4335; color: white;">Submit with Structured JSON</button>
    <button onclick="submitPrompt(true, true)" style="background: #9c27b0; color: white;">Stream + Structured JSON</button>
    <button onclick="clearResponse()">Clear Response</button>
    <div id="timer" style="font-weight: bold; margin: 10px 0; color: #333;"></div>
    <div id="status" class="status" style="display: none;"></div>
    <h4>Response:</h4>
    <textarea id="responseOutput" rows="15" placeholder="Gemini response will appear here..." readonly></textarea>
    
    <div id="prettyJsonContainer" style="margin-top: 10px;">
        <h4>Pretty-Printed JSON:</h4>
        <textarea id="prettyJsonOutput" rows="15" placeholder="Pretty-printed JSON will appear here..." readonly></textarea>
    </div>
    
    <script>
        let requestStartTime = 0;
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }

        async function submitPrompt(useStreaming = false, useStructuredOutput = false) {
            const prompt = document.getElementById('promptInput').value.trim();
            if (!prompt) return showStatus('Please enter a prompt', 'error');

            console.log('=== CLIENT: Submitting prompt ===');
            console.log('Prompt:', prompt);
            console.log('Streaming:', useStreaming);
            console.log('Structured Output:', useStructuredOutput);

            // Start timer
            requestStartTime = performance.now();
            const timerElement = document.getElementById('timer');
            timerElement.textContent = 'Timer: Sending request to Gemini...';
            let statusMessage = 'Processing prompt...';
            if (useStreaming) statusMessage = 'Processing prompt with streaming...';
            if (useStructuredOutput) statusMessage = 'Processing prompt with structured JSON output...';
            showStatus(statusMessage, 'info');
            
            // Clear previous response
            const responseOutput = document.getElementById('responseOutput');
            responseOutput.value = '';
            
            // Clear pretty JSON output
            const prettyJsonOutput = document.getElementById('prettyJsonOutput');
            prettyJsonOutput.value = '';

            try {
                if (useStreaming) {
                    console.log('CLIENT: Using Server-Sent Events for streaming');
                    let firstChunkTime = null;
                    
                    const response = await fetch('/api/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: prompt, stream: true, structuredOutput: useStructuredOutput })
                    });

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') {
                                    const totalTime = Math.round(performance.now() - requestStartTime);
                                    timerElement.textContent = `Timer: ${totalTime}ms total (first chunk: ${firstChunkTime}ms)`;
                                    showStatus('Streaming complete!', 'success');
                                    
                                    // If structured output, parse and pretty-print the accumulated JSON
                                    if (useStructuredOutput && responseOutput.value) {
                                        try {
                                            const jsonData = JSON.parse(responseOutput.value);
                                            prettyJsonOutput.value = JSON.stringify(jsonData, null, 2);
                                        } catch (e) {
                                            console.error('Failed to parse JSON for pretty printing:', e);
                                            prettyJsonOutput.value = 'Error: Failed to parse JSON';
                                        }
                                    }
                                } else {
                                    try {
                                        const parsed = JSON.parse(data);
                                        if (parsed.text) {
                                            if (!firstChunkTime) {
                                                firstChunkTime = Math.round(performance.now() - requestStartTime);
                                                timerElement.textContent = `Timer: ${firstChunkTime}ms to first chunk (streaming...)`;
                                            }
                                            responseOutput.value += parsed.text;
                                            responseOutput.scrollTop = responseOutput.scrollHeight;
                                        } else if (parsed.error) {
                                            throw new Error(parsed.error);
                                        }
                                    } catch (e) {
                                        console.error('Error parsing SSE data:', e);
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Non-streaming mode (original implementation)
                    console.log('CLIENT: Sending POST request to /api/gemini');
                    const response = await fetch('/api/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: prompt, structuredOutput: useStructuredOutput })
                    });

                    console.log('CLIENT: Response status:', response.status);
                    console.log('CLIENT: Response headers:', response.headers);

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error('CLIENT: Error response:', errorData);
                        throw new Error(`API Error: ${response.status} - ${errorData.error || 'Unknown error'}`);
                    }

                    const data = await response.json();
                    console.log('CLIENT: Success response:', data);
                    
                    const responseTime = Math.round(performance.now() - requestStartTime);
                    timerElement.textContent = `Timer: ${responseTime}ms to receive response`;
                    
                    if (useStructuredOutput && typeof data.response === 'object') {
                        // Pretty print JSON response
                        responseOutput.value = JSON.stringify(data.response, null, 2);
                    } else {
                        responseOutput.value = data.response || 'No response received';
                    }
                    showStatus('Response received successfully!', 'success');
                }
            } catch (error) {
                console.error('CLIENT: Caught error:', error);
                showStatus(`Error: ${error.message}`, 'error');
                timerElement.textContent = 'Timer: Request failed';
                
                // Display detailed error in response area
                responseOutput.value = `Error Details:\n${error.message}\n\nCheck browser console for more details.`;
            }
        }

        function clearResponse() {
            document.getElementById('responseOutput').value = '';
            document.getElementById('timer').textContent = '';
            document.getElementById('status').style.display = 'none';
        }
    </script>
</body>
</html>