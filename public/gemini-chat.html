<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gemini 2.5 Flash - Chatbot Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; display: flex; flex-direction: column; height: calc(100vh - 40px); }
        h3 { margin-top: 0; }
        .chat-container { flex: 1; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f5f5f5; }
        .message { margin: 10px 0; padding: 8px 12px; border-radius: 5px; }
        .user-message { background: #e3f2fd; margin-left: 20%; text-align: right; }
        .assistant-message { background: #f5f5f5; margin-right: 20%; border: 1px solid #ddd; }
        .assistant-message pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 12px; }
        .input-container { display: flex; gap: 10px; }
        #userInput { flex: 1; padding: 10px; font-size: 14px; }
        button { padding: 10px 20px; cursor: pointer; }
        .status { margin: 10px 0; padding: 5px; border-radius: 3px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #cce7ff; color: #004085; }
        #timer { font-weight: bold; margin: 10px 0; color: #333; }
    </style>
</head>
<body>
    <h3>Gemini 2.5 Flash - Chatbot Interface</h3>
    <div id="knowledgeUpload" style="margin-bottom: 20px; padding: 15px; background: #f0f8ff; border: 1px solid #4CAF50; border-radius: 5px;">
        <label for="fileInput" style="display: block; margin-bottom: 10px; font-weight: bold;">Upload Knowledge Base (Text File):</label>
        <input type="file" id="fileInput" accept=".txt" style="margin-bottom: 10px;">
        <div id="fileInfo" style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 3px;">
            <strong>Loaded:</strong> <span id="fileName"></span> (<span id="fileSize"></span>)
        </div>
        <div style="margin-top: 10px;">
            <label style="display: flex; align-items: center; gap: 5px;">
                <input type="checkbox" id="showFullResponse">
                <span>Show full API response (debug mode)</span>
            </label>
        </div>
    </div>
    <div id="chatContainer" class="chat-container"></div>
    <div id="timer"></div>
    <div id="cacheInfo" style="margin: 10px 0; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 3px; display: none;">
        <strong>Cache Stats:</strong> <span id="cacheStats"></span>
    </div>
    <div id="status" class="status" style="display: none;"></div>
    <div class="input-container">
        <input type="text" id="userInput" placeholder="Type your message..." disabled>
        <button onclick="clearChat()">Clear Chat</button>
    </div>
    
    <script>
        let conversationHistory = [];
        let requestStartTime = 0;
        let isStreaming = false;
        let knowledgeBaseContent = '';
        let knowledgeBaseFileName = '';
        
        const userInput = document.getElementById('userInput');
        const chatContainer = document.getElementById('chatContainer');
        const timerElement = document.getElementById('timer');
        
        // Enable input on load
        window.onload = () => {
            userInput.disabled = false;
            userInput.focus();
            setupFileUpload();
        };
        
        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file && file.type === 'text/plain') {
                    try {
                        knowledgeBaseContent = await file.text();
                        knowledgeBaseFileName = file.name;
                        
                        // Update UI
                        document.getElementById('fileName').textContent = file.name;
                        document.getElementById('fileSize').textContent = formatFileSize(file.size);
                        document.getElementById('fileInfo').style.display = 'block';
                        
                        showStatus(`Knowledge base "${file.name}" loaded successfully! (${knowledgeBaseContent.length} characters)`, 'success');
                    } catch (error) {
                        showStatus(`Error reading file: ${error.message}`, 'error');
                    }
                } else {
                    showStatus('Please select a text file (.txt)', 'error');
                    event.target.value = '';
                }
            });
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
            else return Math.round(bytes / (1024 * 1024) * 10) / 10 + ' MB';
        }
        
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isStreaming) {
                sendMessage();
            }
        });
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }
        
        function addMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role === 'user' ? 'user-message' : 'assistant-message'}`;
            
            if (role === 'user') {
                messageDiv.textContent = content;
            } else {
                const pre = document.createElement('pre');
                pre.textContent = content;
                messageDiv.appendChild(pre);
            }
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;
            
            // Disable input during streaming
            isStreaming = true;
            userInput.disabled = true;
            userInput.value = '';
            
            // Add user message to UI and history
            addMessage('user', message);
            conversationHistory.push({
                role: 'user',
                parts: [{ text: message }]
            });
            
            // Start timer
            requestStartTime = performance.now();
            timerElement.textContent = 'Timer: Sending request to Gemini...';
            showStatus('Processing with streaming JSON output...', 'info');
            
            // Create placeholder for assistant response
            const assistantDiv = document.createElement('div');
            assistantDiv.className = 'message assistant-message';
            const pre = document.createElement('pre');
            assistantDiv.appendChild(pre);
            chatContainer.appendChild(assistantDiv);
            
            let fullResponse = '';
            let firstChunkTime = null;
            
            try {
                const requestBody = {
                    contents: conversationHistory,
                    structuredOutput: true
                };
                
                // Add knowledge base to system prompt if available
                if (knowledgeBaseContent) {
                    requestBody.systemInstruction = `You are a helpful assistant. You have access to the following knowledge base content from "${knowledgeBaseFileName}":\n\n${knowledgeBaseContent}\n\nWhen answering questions, refer to this knowledge base when relevant. If the user asks about something not in the knowledge base, state that it's not discussed in the provided content and use your general knowledge instead.`;
                }
                
                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                const totalTime = Math.round(performance.now() - requestStartTime);
                                timerElement.textContent = `Timer: ${totalTime}ms total (first chunk: ${firstChunkTime}ms)`;
                                showStatus('Streaming complete!', 'success');
                                
                                // Add complete response to conversation history
                                conversationHistory.push({
                                    role: 'model',
                                    parts: [{ text: fullResponse }]
                                });
                            } else {
                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.text) {
                                        if (!firstChunkTime) {
                                            firstChunkTime = Math.round(performance.now() - requestStartTime);
                                            timerElement.textContent = `Timer: ${firstChunkTime}ms to first chunk (streaming...)`;
                                        }
                                        fullResponse += parsed.text;
                                        
                                        // Check if we should show full response or just JSON
                                        const showFullResponse = document.getElementById('showFullResponse').checked;
                                        if (showFullResponse) {
                                            pre.textContent = fullResponse;
                                        } else {
                                            // Try to parse as JSON and show formatted
                                            try {
                                                const jsonData = JSON.parse(fullResponse);
                                                if (jsonData.sentences && Array.isArray(jsonData.sentences)) {
                                                    pre.textContent = jsonData.sentences.join(' ');
                                                } else {
                                                    pre.textContent = fullResponse;
                                                }
                                            } catch (e) {
                                                // If not valid JSON yet, show as is
                                                pre.textContent = fullResponse;
                                            }
                                        }
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                    } else if (parsed.cacheInfo) {
                                        // Display cache information
                                        const cacheDiv = document.getElementById('cacheInfo');
                                        const cacheStats = document.getElementById('cacheStats');
                                        cacheStats.textContent = `${parsed.cacheInfo.cachedTokens} cached tokens out of ${parsed.cacheInfo.totalTokens} total (${Math.round(parsed.cacheInfo.cacheHitRate * 100)}% cache hit rate)`;
                                        cacheDiv.style.display = 'block';
                                    } else if (parsed.error) {
                                        throw new Error(parsed.error);
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error: ${error.message}`, 'error');
                timerElement.textContent = 'Timer: Request failed';
                pre.textContent = `Error: ${error.message}`;
            } finally {
                // Re-enable input
                isStreaming = false;
                userInput.disabled = false;
                userInput.focus();
            }
        }
        
        function clearChat() {
            conversationHistory = [];
            chatContainer.innerHTML = '';
            timerElement.textContent = '';
            document.getElementById('status').style.display = 'none';
            userInput.focus();
        }
    </script>
</body>
</html>