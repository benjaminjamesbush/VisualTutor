<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Gemini 2.5 Flash - Chatbot Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; display: flex; flex-direction: column; height: calc(100vh - 40px); }
        h3 { margin-top: 0; }
        .chat-container { flex: 1; overflow-y: auto; border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; background: #f5f5f5; }
        .message { margin: 10px 0; padding: 8px 12px; border-radius: 5px; }
        .user-message { background: #e3f2fd; margin-left: 20%; text-align: right; }
        .assistant-message { background: #f5f5f5; margin-right: 20%; border: 1px solid #ddd; }
        .assistant-message pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 12px; }
        .input-container { display: flex; gap: 10px; }
        #userInput { flex: 1; padding: 10px; font-size: 14px; }
        button { padding: 10px 20px; cursor: pointer; }
        .status { margin: 10px 0; padding: 5px; border-radius: 3px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #cce7ff; color: #004085; }
        #timer { font-weight: bold; margin: 10px 0; color: #333; }
    </style>
</head>
<body>
    <h3>Gemini 2.5 Flash - Chatbot Interface</h3>
    <div id="knowledgeUpload" style="margin-bottom: 20px; padding: 15px; background: #f0f8ff; border: 1px solid #4CAF50; border-radius: 5px;">
        <label for="fileInput" style="display: block; margin-bottom: 10px; font-weight: bold;">Upload Knowledge Base (Text File):</label>
        <input type="file" id="fileInput" accept=".txt" style="margin-bottom: 10px;">
        <div id="fileInfo" style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 3px;">
            <strong>Loaded:</strong> <span id="fileName"></span> (<span id="fileSize"></span>)
        </div>
    </div>
    <div id="chatContainer" class="chat-container"></div>
    <div id="timer"></div>
    <!-- Cache info commented out until cachedContentTokenCount is fixed
    <div id="cacheInfo" style="margin: 10px 0; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 3px; display: none;">
        <strong>Cache Stats:</strong> <span id="cacheStats"></span>
    </div>
    -->
    <div id="status" class="status" style="display: none;"></div>
    <div class="input-container">
        <input type="text" id="userInput" placeholder="Type your message..." disabled>
        <button onclick="clearChat()">Clear Chat</button>
    </div>
    
    <script>
        let conversationHistory = [];
        let requestStartTime = 0;
        let isStreaming = false;
        let knowledgeBaseContent = '';
        let knowledgeBaseFileName = '';
        let currentAbortController = null;
        
        const userInput = document.getElementById('userInput');
        const chatContainer = document.getElementById('chatContainer');
        const timerElement = document.getElementById('timer');
        
        // Enable input on load
        window.onload = () => {
            userInput.disabled = false;
            userInput.focus();
            setupFileUpload();
        };
        
        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file && file.type === 'text/plain') {
                    try {
                        knowledgeBaseContent = await file.text();
                        knowledgeBaseFileName = file.name;
                        
                        // Update UI
                        document.getElementById('fileName').textContent = file.name;
                        document.getElementById('fileSize').textContent = formatFileSize(file.size);
                        document.getElementById('fileInfo').style.display = 'block';
                        
                        showStatus(`Knowledge base "${file.name}" loaded successfully! (${knowledgeBaseContent.length} characters)`, 'success');
                    } catch (error) {
                        showStatus(`Error reading file: ${error.message}`, 'error');
                    }
                } else {
                    showStatus('Please select a text file (.txt)', 'error');
                    event.target.value = '';
                }
            });
        }
        
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' bytes';
            else if (bytes < 1024 * 1024) return Math.round(bytes / 1024) + ' KB';
            else return Math.round(bytes / (1024 * 1024) * 10) / 10 + ' MB';
        }
        
        function fixIncompleteJSON(partialJSON) {
            // Try to parse as-is first
            try {
                return JSON.parse(partialJSON);
            } catch (e) {
                // Not valid JSON, attempt to fix it
            }
            
            let fixed = partialJSON.trim();
            
            // Check if we're in the middle of a string by counting quotes
            let quoteCount = 0;
            let inString = false;
            let lastChar = '';
            
            for (let i = 0; i < fixed.length; i++) {
                const char = fixed[i];
                if (char === '"' && lastChar !== '\\') {
                    quoteCount++;
                    inString = !inString;
                }
                lastChar = char;
            }
            
            // If we're in the middle of a string, close it
            if (inString) {
                fixed += '"';
            }
            
            // Check if we need to close the array
            if (!fixed.includes('"]')) {
                // Find the last occurrence of sentences array
                const sentencesIndex = fixed.lastIndexOf('"sentences"');
                if (sentencesIndex !== -1) {
                    // Check if array is not closed
                    const afterSentences = fixed.substring(sentencesIndex);
                    if (afterSentences.includes('[') && !afterSentences.includes(']')) {
                        fixed += ']';
                    }
                }
            }
            
            // Check if we need to close the object
            if (!fixed.endsWith('}')) {
                fixed += '}';
            }
            
            // Try to parse the fixed JSON
            try {
                const parsed = JSON.parse(fixed);
                // Add interruption marker if sentences array exists
                if (parsed.sentences && Array.isArray(parsed.sentences)) {
                    parsed.sentences.push('(Response interrupted by user)');
                }
                return parsed;
            } catch (e) {
                // If still can't parse, return a default structure
                return {
                    sentences: ['(Response interrupted by user - partial response could not be recovered)']
                };
            }
        }
        
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                if (isStreaming) {
                    // Interrupt current stream
                    if (currentAbortController) {
                        currentAbortController.abort();
                    }
                } else if (document.activeElement === userInput) {
                    sendMessage();
                }
            }
        });
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
        }
        
        function addMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role === 'user' ? 'user-message' : 'assistant-message'}`;
            
            if (role === 'user') {
                messageDiv.textContent = content;
            } else {
                const pre = document.createElement('pre');
                pre.textContent = content;
                messageDiv.appendChild(pre);
            }
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;
            
            // Disable input during streaming
            isStreaming = true;
            userInput.disabled = true;
            userInput.value = '';
            userInput.placeholder = 'Press Enter to interrupt...';
            
            // Add user message to UI and history
            addMessage('user', message);
            conversationHistory.push({
                role: 'user',
                parts: [{ text: message }]
            });
            
            // Start timer
            requestStartTime = performance.now();
            timerElement.textContent = 'Timer: Sending request to Gemini...';
            showStatus('Processing with streaming JSON output...', 'info');
            
            // Create placeholder for assistant response
            const assistantDiv = document.createElement('div');
            assistantDiv.className = 'message assistant-message';
            const pre = document.createElement('pre');
            assistantDiv.appendChild(pre);
            chatContainer.appendChild(assistantDiv);
            
            let fullResponse = '';
            let firstChunkTime = null;
            
            try {
                // Create new AbortController for this request
                currentAbortController = new AbortController();
                
                const requestBody = {
                    contents: conversationHistory,
                    structuredOutput: true
                };
                
                // Add knowledge base to system prompt if available
                if (knowledgeBaseContent) {
                    console.log('Knowledge base loaded:', knowledgeBaseFileName, 'Length:', knowledgeBaseContent.length);
                    requestBody.systemInstruction = `You are a helpful assistant. You have access to the following knowledge base content from "${knowledgeBaseFileName}":\n\n${knowledgeBaseContent}\n\nWhen answering questions, refer to this knowledge base when relevant. If the user asks about something not in the knowledge base, state that it's not discussed in the provided content and use your general knowledge instead.`;
                } else {
                    console.log('No knowledge base loaded');
                }
                
                const response = await fetch('/api/gemini', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: currentAbortController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                const totalTime = Math.round(performance.now() - requestStartTime);
                                timerElement.textContent = `Timer: ${totalTime}ms total (first chunk: ${firstChunkTime}ms)`;
                                showStatus('Streaming complete!', 'success');
                                
                                // Add complete response to conversation history
                                conversationHistory.push({
                                    role: 'model',
                                    parts: [{ text: fullResponse }]
                                });
                            } else {
                                try {
                                    const parsed = JSON.parse(data);
                                    if (parsed.text) {
                                        if (!firstChunkTime) {
                                            firstChunkTime = Math.round(performance.now() - requestStartTime);
                                            timerElement.textContent = `Timer: ${firstChunkTime}ms to first chunk (streaming...)`;
                                        }
                                        fullResponse += parsed.text;
                                        // Show the raw response (which should be JSON)
                                        pre.textContent = fullResponse;
                                        chatContainer.scrollTop = chatContainer.scrollHeight;
                                    } else if (parsed.cacheInfo) {
                                        // Cache info commented out until cachedContentTokenCount is fixed
                                        // const cacheDiv = document.getElementById('cacheInfo');
                                        // const cacheStats = document.getElementById('cacheStats');
                                        // cacheStats.textContent = `${parsed.cacheInfo.cachedTokens} cached tokens out of ${parsed.cacheInfo.totalTokens} total (${Math.round(parsed.cacheInfo.cacheHitRate * 100)}% cache hit rate)`;
                                        // cacheDiv.style.display = 'block';
                                    } else if (parsed.error) {
                                        throw new Error(parsed.error);
                                    }
                                } catch (e) {
                                    console.error('Error parsing SSE data:', e);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // Handle user interruption
                    showStatus('Response interrupted', 'info');
                    const totalTime = Math.round(performance.now() - requestStartTime);
                    timerElement.textContent = `Timer: ${totalTime}ms (interrupted)`;
                    
                    // Fix incomplete JSON and add to conversation history
                    if (fullResponse) {
                        const fixedResponse = fixIncompleteJSON(fullResponse);
                        
                        // Update the display with the fixed JSON
                        pre.textContent = JSON.stringify(fixedResponse, null, 2);
                        
                        // Add the interrupted response to conversation history
                        conversationHistory.push({
                            role: 'model',
                            parts: [{ text: JSON.stringify(fixedResponse) }]
                        });
                    } else {
                        // No response received before interruption
                        const emptyResponse = { sentences: ['(Response interrupted before any content was received)'] };
                        pre.textContent = JSON.stringify(emptyResponse, null, 2);
                        conversationHistory.push({
                            role: 'model',
                            parts: [{ text: JSON.stringify(emptyResponse) }]
                        });
                    }
                } else {
                    // Handle other errors
                    console.error('Error:', error);
                    showStatus(`Error: ${error.message}`, 'error');
                    timerElement.textContent = 'Timer: Request failed';
                    pre.textContent = `Error: ${error.message}`;
                }
            } finally {
                // Re-enable input and clear abort controller
                isStreaming = false;
                userInput.disabled = false;
                userInput.placeholder = 'Type your message...';
                userInput.focus();
                currentAbortController = null;
            }
        }
        
        function clearChat() {
            conversationHistory = [];
            chatContainer.innerHTML = '';
            timerElement.textContent = '';
            document.getElementById('status').style.display = 'none';
            userInput.focus();
        }
    </script>
</body>
</html>